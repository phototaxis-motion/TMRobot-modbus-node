output =>
 [14512, 0, 47198, 8192,17076, 27,47294, 8192,17076, 11, 14681, 43008]

convert => 
[
  0.00008392333984375,
  -0.00005295872688293457,
  90.00020599365234,
  -0.00009065866470336914,
  90.00008392333984,
  0.00020757317543029785
] 

origin => 
 [0, -0, 90, 0, 90, 0]

========================================================
output =>
 [ 16948, 2, 47466, 3072, 17076, 41, 47592, 57344, 17076, 21, 14681, 43008 ]

convert => 
[
  45.00000762939453,
  -0.00022320449352264404,
  90.00031280517578,
  -0.00044417381286621094,
  90.00016021728516,
  0.00020757317543029785
] 

origin => 
 [45, -0, 90, -0, 90, 0]

========================================================
output =>
[ 16948 ,38 ,49716 ,13 ,17076 ,47 ,47585 ,49152 ,17076 ,20 ,14709 ,58368 ]

convert => 
[
  45.000144958496094,
  -45.00004959106445,
  90.00035858154297,
  -0.0004305839538574219,
  90.00015258789062,
  0.00023449957370758057
] 

origin => 
[ 45, -45, 90, -0, 90, 0 ]

================================================================
output =>
[ 14560, 0 , 47262 , 45056, 14594 , 39936, 47592, 57344, 14290, 8192, 14709 ,58368 ]

convert => 
[
  0.0001068115234375,
  -0.0000756680965423584,
  0.00012455880641937256,
  -0.00044417381286621094,
  0.00002504885196685791,
  0.00023449957370758057
]

origin => 
[ -0, 0, -0, -0, 0, 0 ]

##################### 專案紀錄 ##################### 
發現 Modbus Slave 輸入有限制
-32767 ~ 32768 最大整數(不重要)
且回傳的數值不明意義(與實際度數無線性相關)
會超過32768
也就是 Mobuse 會先將複雜的正負浮點數轉有限的非負整數

自己測試轉置的數值 
Modbus Slave Input 
[14512, 0, 47198, 8192,17076, 27,47294, 8192,17076, 11, 14681, 43008]
=>
[-18255, -32767, 14431, -24575, -15691, -32740, 14527, -24575, -15691, -32756, -18086, 10241]

回傳結果
output =>
{
  data: [47281, 32769, 14431,40961, 49845, 32796,14527, 40961, 49845,32780, 47450, 10241],
  buffer: <Buffer b8 b1 80 01 38 5f a0 01 c2 b5 80 1c 38 bf a0 01 c2 b5 80 0c b9 5a 28 01>
}
<Buffer b8 b1 80 01 38 5f a0 01 c2 b5 80 1c 38 bf a0 01 c2 b5 80 0c b9 5a 28 01>

在查詢網路上Function後
發現buffer readFloatBE後
與起初的數字只有正負號相反
readFloatBE =>
[
  -0.0000846386028570123,
  0.00005331635838956572,
  -90.75021362304688,
  0.00009137392771663144,
  -90.75009155273438,
  -0.0002080500271404162
]

output data 轉成16進位 存buffer會溢位

舉例 47281 轉16進位是 b8b1 
直接 存 Buffer 只會得到 <Buffer b1>
整數再以 Double Word 4個Byte做傳輸訊號

Buffer 轉 int 第一個轉換都要進兩位(也就是乘上16*16)
b8 => parseInt('b8', 16) = 184 => 184 * 16 * 16 = 47104
b1 => parseInt('b1', 16) = 177 => 47104 + 177 = 47281

反之，(47281).toString(16)，再去對切也可以獲得 Buffer 16進位值



[buf.readFloatBE(0),buf.readFloatBE(4),buf.readFloatBE(8),buf.readFloatBE(12),buf.readFloatBE(16),buf.readFloatBE(20)]
##################### 專案紀錄 ##################### 
